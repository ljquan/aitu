import React, { useState, useEffect, useRef, useMemo } from 'react';
import './ttd-dialog.scss';
import './ai-video-generation.scss';
import { useDrawnix } from '../../hooks/use-drawnix';
import { useI18n } from '../../i18n';
import { useBoard } from '@plait-board/react-board';
import { type Language } from '../../constants/prompts';
import { getSelectedElements, PlaitElement, getRectangleByElements, Point } from '@plait/core';
import { videoGeminiClient } from '../../utils/gemini-api';
import { getInsertionPointForSelectedElements } from '../../utils/selection-utils';
import { insertVideoFromUrl } from '../../data/video';
import { 
  GenerationHistory, 
  VideoHistoryItem, 
  ImageHistoryItem,
  loadVideoHistory,
  saveVideoToHistory,
  generateHistoryId
} from '../generation-history';
import {
  useGenerationState,
  useKeyboardShortcuts,
  handleApiKeyError,
  isInvalidTokenError,
  createCacheManager,
  PreviewCacheBase,
  getPromptExample,
  ActionButtons,
  ErrorDisplay,
  ImageUpload,
  LoadingState,
  PromptInput,
  type ImageFile,
  getMergedPresetPrompts,
  savePromptToHistory as savePromptToHistoryUtil,
  generateVideoThumbnail as generateThumbnail,
  updateHistoryWithGeneratedContent,
  DEFAULT_VIDEO_DIMENSIONS,
  getReferenceDimensionsFromIds
} from './shared';
import { AI_VIDEO_GENERATION_PREVIEW_CACHE_KEY as PREVIEW_CACHE_KEY } from '../../constants/storage';
import { useTaskQueue } from '../../hooks/useTaskQueue';
import { TaskType } from '../../types/task.types';
import { MessagePlugin } from 'tdesign-react';

// è§†é¢‘URLæ¥å£
interface VideoUrls {
  previewUrl: string;
  downloadUrl: string;
}

interface PreviewCache extends PreviewCacheBase {
  generatedVideo: VideoUrls | null;
  sourceImage?: string;
}

const cacheManager = createCacheManager<PreviewCache>(PREVIEW_CACHE_KEY);



interface AIVideoGenerationProps {
  initialPrompt?: string;
  initialImage?: ImageFile;
}

const AIVideoGeneration = ({ initialPrompt = '', initialImage }: AIVideoGenerationProps = {}) => {
  const [prompt, setPrompt] = useState(initialPrompt);
  const [generatedVideo, setGeneratedVideo] = useState<{
    previewUrl: string;
    downloadUrl: string;
  } | null>(null);
  const [isInserting, setIsInserting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [uploadedImage, setUploadedImage] = useState<ImageFile | null>(initialImage || null);
  const [historyItems, setHistoryItems] = useState<VideoHistoryItem[]>([]);
  
  const { isGenerating, isLoading: videoLoading, updateIsGenerating, updateIsLoading: updateVideoLoading } = useGenerationState('video');

  const { appState, setAppState } = useDrawnix();
  const { language } = useI18n();
  const board = useBoard();
  const { createTask } = useTaskQueue();

  // ä¿å­˜é€‰ä¸­å…ƒç´ çš„IDï¼Œç”¨äºè®¡ç®—æ’å…¥ä½ç½®
  const [selectedElementIds, setSelectedElementIds] = useState<string[]>([]);
  
  // è§†é¢‘å…ƒç´ å¼•ç”¨ï¼Œç”¨äºæ§åˆ¶æ’­æ”¾çŠ¶æ€
  const videoRef = useRef<HTMLVideoElement>(null);


  // è®¡ç®—è§†é¢‘æ’å…¥ä½ç½®
  const calculateInsertionPoint = (): Point | undefined => {
    if (!board) {
      console.warn('Board is not available');
      return undefined;
    }

    // ä¼˜å…ˆä½¿ç”¨ä¿å­˜çš„é€‰ä¸­å…ƒç´ ID
    if (selectedElementIds.length > 0 && board.children && Array.isArray(board.children)) {
      const allElements = board.children as PlaitElement[];
      const savedSelectedElements = allElements.filter(el => 
        selectedElementIds.includes((el as any).id || '')
      );
      
      if (savedSelectedElements.length > 0) {
        const rectangle = getRectangleByElements(board, savedSelectedElements, false);
        const centerX = rectangle.x + rectangle.width / 2;
        const bottomY = rectangle.y + rectangle.height + 20; // åœ¨åº•éƒ¨ç•™20pxé—´è·
        return [centerX, bottomY] as Point;
      }
    }

    // ä½¿ç”¨å·¥å…·å‡½æ•°è·å–å½“å‰é€‰ä¸­å…ƒç´ çš„æ’å…¥ä½ç½®
    const calculatedPoint = getInsertionPointForSelectedElements(board);
    return calculatedPoint || undefined;
  };

  useEffect(() => {
    const cachedData = cacheManager.load();
    if (cachedData) {
      setPrompt(cachedData.prompt);
      setGeneratedVideo(cachedData.generatedVideo);
    }

    if (board) {
      const currentSelectedElements = getSelectedElements(board);
      const elementIds = currentSelectedElements.map(el => (el as any).id || '').filter(Boolean);
      setSelectedElementIds(elementIds);
      console.log('Saved selected element IDs for video insertion:', elementIds);
    }
  }, [board]);

  // åŠ è½½å†å²è®°å½•
  useEffect(() => {
    const history = loadVideoHistory();
    setHistoryItems(history);
  }, []);

  useEffect(() => {
    setPrompt(initialPrompt);
    setUploadedImage(initialImage || null);
    setError(null);
  }, [initialPrompt, initialImage]);

  useEffect(() => {
    setError(null);
  }, []);


  const handleReset = () => {
    if (videoRef.current) {
      videoRef.current.pause();
      videoRef.current.src = '';
      videoRef.current.load();
    }
    
    setPrompt('');
    setUploadedImage(null);
    setGeneratedVideo(null);
    setError(null);
    cacheManager.clear();
    window.dispatchEvent(new CustomEvent('ai-video-clear'));
  };

  // è®¾ç½®ç”Ÿæˆè§†é¢‘å¹¶é¢„åŠ è½½
  const setGeneratedVideoWithPreload = async (videoUrls: VideoUrls) => {
    updateVideoLoading(true);
    try {
      setGeneratedVideo(videoUrls);
      
      // ä¿å­˜åˆ°ç¼“å­˜
      const cacheData: PreviewCache = {
        prompt,
        generatedVideo: videoUrls,
        timestamp: Date.now(),
        sourceImage: uploadedImage instanceof File ? URL.createObjectURL(uploadedImage) : uploadedImage?.url
      };
      cacheManager.save(cacheData);

      // å¼‚æ­¥ç”Ÿæˆè§†é¢‘ç¼©ç•¥å›¾ï¼ˆä½¿ç”¨é¢„è§ˆURLï¼‰
      const thumbnailPromise = generateThumbnail(videoUrls.previewUrl);

      // æ›´æ–°å·²æœ‰çš„æç¤ºè¯è®°å½•ï¼Œæ·»åŠ ç”Ÿæˆçš„è§†é¢‘ä¿¡æ¯
      const existingHistory = loadVideoHistory();
      const existingIndex = existingHistory.findIndex(item => item.prompt.trim() === prompt.trim());
      
      if (existingIndex >= 0) {
        // å¦‚æœæ‰¾åˆ°äº†ç›¸åŒæç¤ºè¯çš„è®°å½•ï¼Œæ›´æ–°å®ƒçš„è§†é¢‘ä¿¡æ¯
        const updatedItem = {
          ...existingHistory[existingIndex],
          previewUrl: videoUrls.previewUrl,
          downloadUrl: videoUrls.downloadUrl,
          timestamp: Date.now(), // æ›´æ–°æ—¶é—´æˆ³
        };
        
        // ç­‰å¾…ç¼©ç•¥å›¾ç”Ÿæˆå®Œæˆï¼Œç„¶åæ›´æ–°imageUrl
        try {
          const thumbnail = await thumbnailPromise;
          if (thumbnail) {
            updatedItem.imageUrl = thumbnail; // ä½¿ç”¨ç¼©ç•¥å›¾ä½œä¸º imageUrl
          } else {
            // å¦‚æœç¼©ç•¥å›¾ç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨é¢„è§ˆURL
            updatedItem.imageUrl = videoUrls.previewUrl;
          }
        } catch (error) {
          console.warn('Failed to generate video thumbnail:', error);
          // å¦‚æœç¼©ç•¥å›¾ç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨é¢„è§ˆURL
          updatedItem.imageUrl = videoUrls.previewUrl;
        }
        
        // æ›´æ–°å†å²è®°å½•
        saveVideoToHistory(updatedItem);
        
        // æ›´æ–°å†å²åˆ—è¡¨çŠ¶æ€
        const updatedHistoryItem: VideoHistoryItem = { ...updatedItem, type: 'video' };
        setHistoryItems(prev => [updatedHistoryItem, ...prev.filter(h => h.id !== updatedItem.id)].slice(0, 50));
      } else {
        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ›å»ºæ–°è®°å½•ï¼ˆç†è®ºä¸Šä¸åº”è¯¥åˆ°è¿™é‡Œï¼Œå› ä¸ºå·²åœ¨handleGenerateä¸­ä¿å­˜äº†ï¼‰
        const historyItem: Omit<VideoHistoryItem, 'type'> = {
          id: generateHistoryId(),
          prompt,
          imageUrl: '', // å…ˆç½®ç©ºï¼Œç­‰å¾…ç¼©ç•¥å›¾ç”Ÿæˆ
          width: 400,   // é»˜è®¤å°ºå¯¸
          height: 225,  // é»˜è®¤å°ºå¯¸
          previewUrl: videoUrls.previewUrl,
          downloadUrl: videoUrls.downloadUrl,
          timestamp: Date.now()
        };

        // ç­‰å¾…ç¼©ç•¥å›¾ç”Ÿæˆå®Œæˆï¼Œç„¶åæ›´æ–°å†å²è®°å½•
        try {
          const thumbnail = await thumbnailPromise;
          if (thumbnail) {
            historyItem.imageUrl = thumbnail; // ä½¿ç”¨ç¼©ç•¥å›¾ä½œä¸º imageUrl
          } else {
            // å¦‚æœç¼©ç•¥å›¾ç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨é¢„è§ˆURL
            historyItem.imageUrl = videoUrls.previewUrl;
          }
        } catch (error) {
          console.warn('Failed to generate video thumbnail:', error);
          // å¦‚æœç¼©ç•¥å›¾ç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨é¢„è§ˆURL
          historyItem.imageUrl = videoUrls.previewUrl;
        }

        saveVideoToHistory(historyItem);
        
        // æ›´æ–°å†å²åˆ—è¡¨çŠ¶æ€
        const newHistoryItem: VideoHistoryItem = { ...historyItem, type: 'video' };
        setHistoryItems(prev => [newHistoryItem, ...prev.filter(h => h.id !== historyItem.id)].slice(0, 50));
      }
    } catch (error) {
      console.warn('Failed to set generated video:', error);
      setGeneratedVideo(videoUrls);
    } finally {
      updateVideoLoading(false);
    }
  };

  // ä»å†å²è®°å½•é€‰æ‹©è§†é¢‘
  const selectFromHistory = (historyItem: VideoHistoryItem) => {
    setPrompt(historyItem.prompt);
    setGeneratedVideo({
      previewUrl: historyItem.previewUrl,
      downloadUrl: historyItem.downloadUrl || historyItem.previewUrl
    });
    // é€‰æ‹©å†å²è®°å½•æ—¶æ¸…é™¤é”™è¯¯çŠ¶æ€
    setError(null);
    
    // æ›´æ–°é¢„è§ˆç¼“å­˜
    const cacheData: PreviewCache = {
      prompt: historyItem.prompt,
      generatedVideo: {
        previewUrl: historyItem.previewUrl,
        downloadUrl: historyItem.downloadUrl || historyItem.previewUrl
      },
      timestamp: Date.now()
    };
    cacheManager.save(cacheData);
  };

  // é€šç”¨å†å²é€‰æ‹©å¤„ç†å™¨ï¼ˆå…¼å®¹å„ç§ç±»å‹ï¼‰
  const handleSelectFromHistory = (item: VideoHistoryItem | ImageHistoryItem) => {
    if (item.type === 'video') {
      selectFromHistory(item as VideoHistoryItem);
    }
    // è§†é¢‘ç”Ÿæˆç»„ä»¶ä¸å¤„ç†å›¾ç‰‡ç±»å‹
  };

  // ä½¿ç”¨useMemoä¼˜åŒ–æ€§èƒ½ï¼Œå½“historyItemsæˆ–languageå˜åŒ–æ—¶é‡æ–°è®¡ç®—
  const presetPrompts = React.useMemo(() => 
    getMergedPresetPrompts('video', language as Language, historyItems), 
    [historyItems, language]
  );

  // ä¿å­˜æç¤ºè¯åˆ°å†å²è®°å½•ï¼ˆå»é‡ï¼‰
  const savePromptToHistory = (promptText: string) => {
    const dimensions = { width: DEFAULT_VIDEO_DIMENSIONS.width, height: DEFAULT_VIDEO_DIMENSIONS.height };
    savePromptToHistoryUtil('video', promptText, dimensions);
  };


  useKeyboardShortcuts(isGenerating, prompt, handleGenerate);

  // ç»„ä»¶å¸è½½æ—¶æ¸…ç†è§†é¢‘æ’­æ”¾
  useEffect(() => {
    return () => {
      // æš‚åœè§†é¢‘æ’­æ”¾
      if (videoRef.current) {
        videoRef.current.pause();
        videoRef.current.src = '';
        videoRef.current.load();
      }
    };
  }, []);

  return (
    <div className="ai-video-generation-container">
      <div className="main-content">
        {/* AI è§†é¢‘ç”Ÿæˆè¡¨å• */}
        <div className="ai-image-generation-section">
          <div className="ai-image-generation-form">
            
            <ImageUpload
              images={uploadedImage ? [uploadedImage] : []}
              onImagesChange={(images) => setUploadedImage(images[0] || null)}
              language={language}
              disabled={isGenerating}
              multiple={false}
              icon="ğŸ¬"
              onError={setError}
            />
            
            <PromptInput
              prompt={prompt}
              onPromptChange={setPrompt}
              presetPrompts={presetPrompts}
              language={language}
              type="video"
              disabled={isGenerating}
              onError={setError}
            />
            
            <ErrorDisplay error={error} />
          </div>
        </div>
        
        <ActionButtons
          language={language}
          type="video"
          isGenerating={isGenerating}
          hasGenerated={!!generatedVideo}
          canGenerate={!!prompt.trim()}
          onGenerate={handleGenerate}
          onReset={handleReset}
        />
      </div>
      
      {/* é¢„è§ˆåŒºåŸŸ */}
      <div className="preview-section">
        <div className="image-preview-container">
          <LoadingState
            language={language}
            type="video"
            isGenerating={isGenerating}
            isLoading={videoLoading}
            hasContent={!!generatedVideo}
          />
          
          {generatedVideo && (
            <div className="preview-image-wrapper">
              <video 
                ref={videoRef}
                src={generatedVideo.previewUrl} 
                controls
                loop
                muted
                className="preview-image"
                style={{ width: '100%', height: '100%', objectFit: 'contain' }}
                onLoadedData={() => console.log('Preview video loaded successfully')}
                onError={() => {
                  console.warn('Preview video failed to load:', generatedVideo.previewUrl);
                }}
              />
            </div>
          )}
        </div>
        
          {/* ç»Ÿä¸€å†å²è®°å½•ç»„ä»¶ */}
          <GenerationHistory
            historyItems={historyItems}
            onSelectFromHistory={handleSelectFromHistory}
            position={{ bottom: '60px', right: '8px' }}
          />
        {/* æ’å…¥ã€ä¸‹è½½å’Œæ¸…é™¤æŒ‰é’®åŒºåŸŸ */}
        {generatedVideo && (
          <div className="section-actions">
            <button
              onClick={() => {
                // æš‚åœå¹¶æ¸…ç†è§†é¢‘
                if (videoRef.current) {
                  videoRef.current.pause();
                  videoRef.current.src = '';
                  videoRef.current.load();
                }
                
                setGeneratedVideo(null);
                try {
                  localStorage.removeItem(PREVIEW_CACHE_KEY);
                } catch (error) {
                  console.warn('Failed to clear cache:', error);
                }
              }}
              disabled={isGenerating || videoLoading}
              className="action-button tertiary"
            >
              {language === 'zh' ? 'æ¸…é™¤' : 'Clear'}
            </button>
            <button
              onClick={async () => {
                if (generatedVideo) {
                  try {
                    setIsInserting(true);
                    console.log('Starting video insertion with URL...', generatedVideo.previewUrl);

                    // è°ƒè¯•ï¼šæ£€æŸ¥å½“å‰é€‰ä¸­çŠ¶æ€
                    const currentSelectedElements = board ? getSelectedElements(board) : [];
                    console.log('Current selected elements:', currentSelectedElements.length, currentSelectedElements);
                    console.log('Saved selected element IDs:', selectedElementIds);

                    // è®¡ç®—å‚è€ƒå°ºå¯¸ï¼ˆç”¨äºé€‚åº”é€‰ä¸­å…ƒç´ çš„å¤§å°ï¼‰
                    const referenceDimensions = getReferenceDimensionsFromIds(board, selectedElementIds);
                    console.log('Reference dimensions for video insertion:', referenceDimensions);

                    // è®¡ç®—æ’å…¥ä½ç½®
                    const insertionPoint = calculateInsertionPoint();
                    console.log('Calculated insertion point:', insertionPoint);

                    await insertVideoFromUrl(board, generatedVideo.previewUrl, insertionPoint, false, referenceDimensions);

                    console.log('Video inserted successfully!');

                    // æ¸…é™¤ç¼“å­˜
                    try {
                      localStorage.removeItem(PREVIEW_CACHE_KEY);
                    } catch (error) {
                      console.warn('Failed to clear cache:', error);
                    }

                    // å…³é—­å¯¹è¯æ¡†
                    setAppState({ ...appState, openDialogType: null });

                  } catch (err) {
                    console.error('Insert video error:', err);
                    setError(
                      language === 'zh'
                        ? 'è§†é¢‘æ’å…¥å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'
                        : 'Video insertion failed, please try again later'
                    );
                  } finally {
                    setIsInserting(false);
                  }
                }
              }}
              disabled={isGenerating || videoLoading || isInserting}
              className="action-button primary"
            >
              {isInserting
                ? (language === 'zh' ? 'æ’å…¥ä¸­...' : 'Inserting...')
                : videoLoading
                ? (language === 'zh' ? 'åŠ è½½ä¸­...' : 'Loading...')
                : (language === 'zh' ? 'æ’å…¥è§†é¢‘' : 'Insert Video')
              }
            </button>
            <button
              onClick={() => {
                if (generatedVideo) {
                  // åœ¨æ–°é¡µé¢æ‰“å¼€ä¸‹è½½é“¾æ¥
                  window.open(generatedVideo.downloadUrl, '_blank');
                }
              }}
              disabled={isGenerating || videoLoading || isInserting}
              className="action-button secondary"
            >
              {videoLoading 
                ? (language === 'zh' ? 'åŠ è½½ä¸­...' : 'Loading...')
                : (language === 'zh' ? 'ä¸‹è½½' : 'Download')
              }
            </button>
          </div>
        )}
      </div>
    </div>
  );
};

export default AIVideoGeneration;