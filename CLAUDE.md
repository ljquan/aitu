# CLAUDE.md

本文件为 Claude Code (claude.ai/code) 在本仓库中工作时提供指导。

---

## 项目概述

**Opentu (开图)** 是一个基于 Plait 框架构建的开源白板应用。支持思维导图、流程图、自由绘画、图片插入，以及 AI 驱动的内容生成（通过 Gemini 生成图片，通过 Veo3/Sora-2 生成视频）。

| 属性 | 值 |
|------|-----|
| 名称 | Opentu (开图) - AI 图片与视频创作工具 |
| 版本 | 0.5.0 |
| 许可证 | MIT |
| 官网 | https://opentu.ai |

---

## 开发命令

```bash
# 开发
pnpm start              # 启动开发服务器 (localhost:7200)
pnpm run build          # 构建所有包
pnpm run build:web      # 仅构建 Web 应用

# 测试与检查
pnpm check              # 类型检查 + ESLint（推荐）
pnpm typecheck          # 仅类型检查
pnpm lint               # 仅 ESLint
pnpm test               # 运行所有测试

# 版本发布
pnpm run version:patch  # 升级补丁版本 (0.0.x)
pnpm run version:minor  # 升级次版本 (0.x.0)
pnpm run release        # 构建并打包发布
```

---

## 项目架构

```
aitu/
├── apps/
│   ├── web/                    # 主 Web 应用 (Vite + React)
│   └── web-e2e/                # E2E 测试 (Playwright)
├── packages/
│   ├── drawnix/                # 核心白板库 (362+ TS 文件)
│   │   ├── components/         # UI 组件 (43 个)
│   │   ├── services/           # 业务服务 (32 个)
│   │   ├── plugins/            # Plait 插件 (15 个)
│   │   ├── hooks/              # React Hooks (27 个)
│   │   └── utils/              # 工具函数 (33 个)
│   ├── react-board/            # Plait React 适配层
│   └── react-text/             # 文本编辑组件 (Slate.js)
├── docs/                       # 项目文档
├── openspec/                   # OpenSpec 规范
└── specs/                      # 功能规格说明
```

### 关键入口文件

| 文件 | 说明 |
|------|------|
| `apps/web/src/main.tsx` | 应用入口 |
| `packages/drawnix/src/drawnix.tsx` | 主编辑器组件 |
| `apps/web/src/sw/index.ts` | Service Worker |
| `packages/drawnix/src/services/generation-api-service.ts` | AI 生成服务 |
| `packages/drawnix/src/services/task-queue-service.ts` | 任务队列服务 |

### 重要 Context

- `DrawnixContext` - 编辑器状态（指针模式、对话框）
- `AssetContext` - 素材库管理
- `WorkflowContext` - AI 工作流状态
- `ChatDrawerContext` - 聊天抽屉状态

---

## 技术栈

| 类别 | 技术 |
|------|------|
| 前端框架 | React 18.3, TypeScript 5.4, Vite 6.2 |
| 构建工具 | Nx 19.3, pnpm, SWC |
| UI 框架 | TDesign React, Tailwind CSS, Lucide React |
| 绘图框架 | Plait ^0.84, Slate.js, RoughJS, Mermaid |
| AI/API | Gemini API, Veo3, Sora-2 |
| 状态管理 | React Context, RxJS, LocalForage |
| 测试 | Vitest, Playwright |

---

## 核心架构概念

### AI 生成流程

```
AIInputBar → swTaskQueueService.createTask()
    ↓ postMessage
Service Worker (后台执行)
    ├── ImageHandler / VideoHandler
    └── IndexedDB 持久化
    ↓ broadcastToClients
应用层 → Canvas 插入 / 媒体库缓存
```

**核心特性**：页面刷新不影响任务执行，通过 `remoteId` 恢复视频轮询。

### 素材库数据来源

1. **本地上传素材** → IndexedDB 元数据 + Cache Storage 数据
2. **AI 生成素材** → 任务队列已完成任务
3. **Cache Storage 媒体** → `/__aitu_cache__/` 前缀

**设计原则**：Cache Storage 是唯一数据真相，IndexedDB 只存元数据。

### 插件系统

采用 `withXxx` 组合式模式：`withTool`, `withFreehand`, `withImage`, `withVideo`, `withWorkzone` 等。

- **新画布功能必须作为 Plait 插件**：涉及画布交互的功能（如激光笔、画笔变体）必须实现为 `withXxx` 插件复用 Generator/Smoother 等已有基础设施，禁止使用独立 React 组件 + SVG overlay（坐标系不一致、事件冲突）
- **工具互斥通过 `board.pointer` 管理**：新增工具类型应加入对应枚举（如 `FreehandShape`），通过 Plait 的 `board.pointer` 单值机制自动互斥，禁止使用独立布尔状态（如 `xxxActive`）手动管理
- **Viewport 缩放+平移用 `updateViewport` 一步完成**：需要同时改变 zoom 和 origination 时，使用 `BoardTransforms.updateViewport(board, origination, zoom)` 一次性设置；禁止 `updateZoom()` + `moveToCenter()` 分两步调用，`updateZoom` 会先改变视口位置，导致 `moveToCenter` 基于错误的视口状态计算偏移。`origination` 是视口左上角在世界坐标中的位置，居中公式：`origination = [centerX - viewportWidth/2/zoom, centerY - viewportHeight/2/zoom]`
- **全屏展示画布局部内容用「viewport 对准 + 隐藏 UI + 蒙层挖洞」**：需要全屏/沉浸式展示某个区域（如 Frame 幻灯片播放）时，三步走：① viewport 对准目标区域（`updateViewport`）；② 给 `document.documentElement` 添加 CSS class（如 `slideshow-active`），用 `display: none !important` 隐藏所有 UI 覆盖层（工具栏、抽屉、面板、输入栏等）；③ 在画布上方渲染全屏蒙层，用四块黑色 div 围住目标区域，中间留出"窗口"。注意：不要用 `toImage` 截图方案（`<defs>` 引用丢失、子元素绑定不完全导致内容缺失），也不要仅操纵 viewport 而不隐藏 UI（抽屉/工具栏会露出来）
- **自定义组件 `onContextChanged` 必须处理 viewport 变化**：自定义 Plait 组件（如 `FrameComponent`、`FreehandComponent`、`PenPathComponent`）的 `onContextChanged` 中，必须检测 viewport 变化（`board.viewport.zoom/offsetX/offsetY`）并在元素被选中时重绘选择框（`activeGenerator.processDrawing`）。选择框渲染在 `board-active-svg`（无 viewBox，坐标通过 `toActiveRectangleFromViewBoxRectangle` 实时计算），而元素渲染在 `board-host-svg`（有 viewBox 自动映射），viewport 变化时选择框不会自动跟随，必须手动重绘。参考 `ToolComponent.onContextChanged` 的实现模式
- **编程式选中元素后必须触发 `onChange` 才会渲染选中框**：`cacheSelectedElements(board, elements)` 只是在 WeakMap 中缓存选中元素列表，不会触发框架的 `onChange` 回调链，因此选中框不会渲染。`addSelectedElement` 内部也只是调用 `cacheSelectedElements`，同样不会触发渲染。要让选中框立即显示，需要使用 `Transforms.addSelectionWithTemporaryElements(board, elements)`——它会将元素存入 `BOARD_TO_TEMPORARY_ELEMENTS`，然后在下一个事件循环调用 `Transforms.setSelection` 触发 `onChange`，`onChange` 中检测到 temporary elements 后执行 `cacheSelectedElements` 并渲染选中框。适用场景：自定义选择逻辑（如套索选择、编程式批量选中）。如果是单个元素在交互流程中选中（如 pointerUp 点击），框架的 `withSelection` 插件会自动处理，无需手动调用

---

## 核心编码规则

> 详细规则和错误示例请参考 `docs/CODING_RULES.md`

### 断舍离原则（最高优先级）

> **极简主义是本项目的核心哲学。代码越少，Bug 越少，维护成本越低。**

1. **坚决删除冗余代码**：发现无用代码立即删除，不犹豫、不"留着以后可能用到"
2. **拒绝重复实现**：主线程已实现的功能，SW 不要再实现一遍；一处写入成功，不需要另一处"同步通知"
3. **质疑每一行代码**：新增代码前问"这真的需要吗？"；能用 10 行解决的不写 100 行
4. **历史包袱及时清理**：架构演进后的遗留代码、废弃的 RPC 调用、不再使用的 Handler 都要删除
5. **YAGNI 原则**：You Aren't Gonna Need It —— 不为假想的未来需求预留代码

### 必须遵守

1. **文件大小限制**：单个文件不超过 500 行
2. **类型定义**：对象用 `interface`，联合类型用 `type`，避免 `any`；枚举作为值使用时不能用 `import type`
3. **组件规范**：函数组件 + Hooks，事件处理器用 `useCallback`
4. **定时器清理**：`setInterval` 必须保存 ID，提供 `destroy()` 方法
5. **API 请求**：禁止重试，区分业务失败和网络错误
6. **调试日志**：提交前必须清理 `console.log`；同步模块（`github-sync/*`）使用 `logDebug/logInfo/logSuccess/logWarning/logError` 而非 `console.log`；**禁止空 catch 块**，至少记录 `console.debug`
7. **敏感信息**：永不硬编码 API Key，使用 `sanitizeObject` 过滤日志，敏感 ID 用 `maskId` 脱敏
8. **布局抖动**：`Suspense` 的 fallback 应撑满容器或固定高度，防止加载时跳动
9. **结构化数据**：复杂消息展示应优先使用 `aiContext` 等结构化数据而非字符串解析
10. **图标验证**：使用 `tdesign-icons-react` 前需验证导出名称是否存在（如 `ServiceIcon`）
11. **外部 API 调用频率**：低频刷新的外部接口必须使用单例控制调用频率
12. **共享模块设计**：相似功能提取到 `*-core.ts` 核心模块，通过配置类型区分行为
13. **同名模块隔离**：多个同名模块有独立全局状态，确保从正确的模块路径导入
14. **工作区初始化**：`getCurrentBoard()` 返回 `null` 但 `hasBoards()` 为 `true` 时，必须自动选择第一个画板，不能只在 "无画板" 时创建新画板
15. **工具函数组织**：通用工具函数放 `@aitu/utils`，使用时直接导入，禁止二次导出或不必要的包装
16. **数据安全保护**：破坏性操作（删除、覆盖）前必须安全检查，当前编辑项不可删除，批量删除需确认，不可逆操作需输入确认文字
17. **模块循环依赖**：将共享函数（如 `shouldUseSWTaskQueue`）提取到独立模块打破循环；单例构造函数用 `queueMicrotask` 延迟访问其他模块导出
18. **配置对象深拷贝**：`getSetting()` 等返回配置对象的方法需返回深拷贝，防止脱敏函数等外部操作修改全局状态
19. **避免过度设计**：优先使用简单的 interface + service 模式；只在有明确需求时才添加 Repository、Strategy 等抽象层
20. **重构先问问题**：重构前明确要解决的实际问题；验证方案是否真的解决问题而非增加复杂度
21. **统计上报旁路化**：统计/监控的初始化与上报须在 requestIdleCallback 或 setTimeout 中执行，不在主路径上做脱敏与网络请求；失败静默不向上抛
22. **第三方 Session Replay**：默认关闭或按采样开启，避免主线程卡顿（wheel/setInterval）与 413；若开启需配置限流与 413 错误处理

### Service Worker 规则

1. SW 和主线程模块不共享，各自维护独立副本
2. 虚拟路径（`/__aitu_cache__/`）由 SW 拦截返回 Cache Storage 数据
3. SW 内部获取缓存数据应直接读取 Cache API，不使用 fetch
4. 更新后禁止自动刷新页面，需用户确认
5. SW 枚举值使用小写（`'completed'`、`'image'`、`'video'`），读取 SW 数据时注意匹配
6. 无效配置下创建的任务不应在后续被执行，首次初始化时应清除"孤儿任务"
7. 跨层数据转换必须传递所有字段，特别是 `options`、`metadata` 等可选字段，遗漏会导致功能静默失败
8. **Cache.put() 会消费 Response body**：需要缓存到多个 key 时，为每个 key 创建独立的 Response 对象，不要复用后 clone
9. **fetchOptions 优先级**：优先尝试 `cors` 模式（可缓存），最后才尝试 `no-cors` 模式（无法缓存）
10. **postmessage-duplex 1.1.0 通信模式**：RPC 用 `call()` 方法（需响应），单向广播用 `broadcast()` + `onBroadcast()`（fire-and-forget）；SW 用 `enableGlobalRouting` 自动管理 channel
11. **postmessage-duplex 单页面单 channel**：同一页面只允许一个 `createFromPage()`（`swChannelClient`），其他模块（如 `FetchRelayClient`）必须复用 `swChannelClient.getChannel()`；多个 channel 会导致 SW `enableGlobalRouting` 按 `clientId` 路由冲突，RPC 响应丢失
12. **postmessage-duplex 消息大小限制**：单次 RPC 响应不超过 1MB，大数据查询需后端分页+精简数据（去掉 requestBody/responseBody 等大字段）
13. **主线程直接读取 IndexedDB**：只读数据直接用 `taskStorageReader.getAllTasks()` 读取，避免 postMessage 限制；写操作通过 SW 或 `taskStorageWriter` 保持一致性
14. **任务数据持久化**：主线程直接通过 `taskStorageWriter` 写入 IndexedDB，无需通过 RPC 通知 SW（断舍离：避免重复写入）
15. **降级模式任务执行**：`?sw=0` 降级模式下，`createTask` 后必须自动触发 `executeTask`，否则任务只会被创建但不会执行
16. **工作流恢复状态不一致**：UI 与 SW 状态不一致时（如终态但有运行中步骤），必须先从 SW 获取真实状态，不能直接标记为失败
17. **错误处理链保持完整**：需要传递特殊错误属性（如 `isAwaitingClient`）时，必须重新抛出原始错误，不能创建新 Error 对象
18. **SW 重发 Tool Request 需延迟**：页面刷新后 claim 工作流时，SW 重发 pending tool request 需延迟 500ms，等待主线程 handler 准备好
19. **同步数据双向合并**：下载远程数据时必须与本地合并（基于 ID 去重，`updatedAt` 判断版本），合并后自动上传确保双向同步
20. **同步数据格式一致性**：`tasks.json` 结构是 `{ completedTasks: Task[] }` 不是数组，画板文件是 `board_{id}.json` 不是 `.drawnix`
21. **RPC 超时与重连**：关键 RPC 调用（如工作流提交）需设置合理超时（15-30秒），超时时主动重新初始化 SW 连接并重试
22. **降级路径功能一致性**：降级到主线程直接调用 API 时，必须保持与 SW 模式相同的功能行为（如 LLM API 日志记录）；工作流工具集也需一致，WorkflowEngine.executeToolStep 中 SW 支持的工具在主线程分支也需有对应 case 路由到 executeMainThreadTool，否则会报 Unknown tool
23. **SW 初始化统一入口**：使用 `swChannelClient.ensureReady()` 作为统一入口，避免在各处重复初始化逻辑；任务队列用 `swTaskQueueService.initialize()`
24. **配置同步到 IndexedDB**：SW 无法访问 localStorage，`SettingsManager` 自动将配置同步到 IndexedDB（同一数据库 `sw-task-queue`），SW 直接从 IndexedDB 读取，避免依赖 postMessage
25. **远程同步任务不恢复执行**：通过 `syncedFromRemote` 标记区分本地和远程任务，SW 的 `shouldResumeTask()` 跳过远程任务，避免多设备重复调用大模型接口
26. **任务参考图传递**：创建图片/视频任务时 `createTask` 的 params 须包含 `referenceImages`（与 `uploadedImages` 一并）；执行时 `executor.generateImage/generateVideo` 须传入 `referenceImages`（或 video 的 `inputReference`），否则 sw=0 降级请求不会带参考图
27. **SW 可用性检测统一**：决定是否走 SW 时需用 `swChannelClient.isInitialized()` + `ping`，不能仅检查 `navigator.serviceWorker.controller`，否则 channel 未就绪会提交超时
28. **降级路径强制主线程执行器**：workflow 提交超时后降级时，MainThreadWorkflowEngine 须传 `forceFallbackExecutor: true`，否则 `executorFactory.getExecutor()` 可能仍返回 SW 执行器导致二次超时
29. **Fetch Relay 初始化超时保护**：`fetchRelayClient.initialize()` 在热路径（如 `generateImage`、`doInitialize`）中必须用 `Promise.race` 加 3s 超时，超时后降级到 `directFetch`
30. **模块迁移接口完整性**：将模块从 SW 迁移到主线程（或反向）时，新模块的 `interface` 定义必须与原模块逐字段对比，确保无遗漏；不仅调用时传参要完整，**类型定义本身**也要包含所有字段（如 `referenceImages`），否则即使调用方想传数据也无法传入

### React 规则

1. Context 回调中必须使用函数式更新 `setState(prev => ...)`
2. Hover 延迟操作需要正确的计时器清理
3. 弹出菜单/浮层需用 `createPortal` 渲染到 body，避免被父容器 overflow 截断
4. 模式切换时多个相关状态需同步更新，封装成一个函数而非直接暴露底层 setMode
5. 图标组件使用 `React.FC`，支持 `size` 属性
6. 传递组件作为 prop 时必须实例化：`icon={<Icon />}` 而非 `icon={Icon}`
7. 内联 style 的 `undefined` 值会覆盖 CSS 类，需要 CSS 类生效时传 `style={undefined}`
8. Flex 布局中使用 `flex: 1` 时，若兄弟元素可隐藏，内部组件需设 `max-width` 防止变形
9. `useCallback` 定义必须在引用它的 `useEffect` 之前，否则会报 TDZ 错误
10. Slate-React Leaf 组件 DOM 结构必须稳定，不能根据条件切换标签/CSS 实现方式
11. **异步操作不阻塞 UI**：远程同步等耗时操作应异步执行（fire-and-forget），不阻塞弹窗关闭
12. **关键操作直接调用**：不依赖 RxJS 事件订阅触发关键业务逻辑，订阅时序不可靠
13. **CPU 密集型循环需 yield**：大量 JSON.stringify/加密等操作的循环，每 3-5 次迭代调用 `await yieldToMain()` 让出主线程
14. **跨 React Root 状态共享**：Plait 文本组件通过 `createRoot` 渲染在独立 React 树中，Context 无法穿透；需用 `useSyncExternalStore` + 模块级 store 共享状态

### 缓存规则

1. IndexedDB 元数据必须验证 Cache Storage 实际数据存在
2. 本地缓存图片只存 Cache Storage，不存 IndexedDB 元数据
3. Cache API 返回前必须验证响应有效性（`blob.size > 0`）
4. **Cache.put() 会消费 Response body**：需要缓存到多个 key 时，为每个 key 创建独立的 Response 对象

---

## 品牌设计

### 核心色彩

| 用途 | 颜色 |
|------|------|
| 主品牌色 | `#F39C12` (橙金) |
| 强调色 | `#5A4FCF` (蓝紫), `#E91E63` (玫红) |
| 品牌渐变 | `linear-gradient(135deg, #F39C12 0%, #E67E22 30%, #5A4FCF 70%, #E91E63 100%)` |

### UI 规范

- **Tooltips**：始终使用 `theme='light'`，高层级容器内需显式设置更高 `zIndex` (如 20000)
- **媒体预览**：统一使用 `UnifiedMediaViewer` 公共组件，禁止自定义 Dialog 实现
- **生成结果缩略图**：使用 `object-fit: contain` 完整展示，禁止 cover 裁切
- **小图 hover 预览**：缩略图应提供 hover 大图预览功能（Portal 渲染到 body）
- **状态表意**：优先使用量化组件（如信号格）而非单一颜色圆点来展示程度差异
- **按钮圆角**：8px
- **卡片圆角**：12px
- **动画时长**：150-300ms，ease-out 曲线
- **可点击容器**：用 `pointer-events: none` + 父容器 `onClick` 扩大交互区域
- **筛选与选中联动**：选中计数、操作都应基于筛选后的结果
- **全局配色统一**：在 `tdesign-theme.scss` 中集中覆盖第三方组件样式
- **组件内颜色**：TDesign CSS 变量可能被覆盖，组件 scss 中应直接使用具体颜色值（如 `rgba(243, 156, 18, 0.12)`）

---

## 相关文档

### 核心文档（按需阅读）

| 文档 | 说明 | 何时阅读 |
|------|------|---------|
| `docs/CODING_RULES.md` | 详细编码规则和错误示例 | 编写代码时遇到特定场景 |
| `docs/FEATURE_FLOWS.md` | 核心功能实现流程 | 理解功能架构时 |
| `docs/CONCEPTS.md` | 项目核心术语定义 | 理解业务概念时 |
| `docs/CODING_STANDARDS.md` | 基础编码规范 | 代码风格参考 |

### 专题文档

- `docs/Z_INDEX_GUIDE.md` - Z-Index 层级管理
- `docs/UNIFIED_CACHE_DESIGN.md` - 缓存架构设计
- `docs/SW_DEBUG_POSTMESSAGE_LOGGING.md` - SW 调试日志
- `docs/CLAUDE_CODE_BEST_PRACTICES.md` - Claude Code 使用技巧

### 规范文档

- `openspec/AGENTS.md` - OpenSpec 规范（涉及架构变更时必读）

---

## OpenSpec 说明

当请求涉及以下内容时，请先打开 `@/openspec/AGENTS.md`：
- 提及计划或提案 (proposal, spec, change, plan)
- 引入新功能、破坏性变更、架构调整
- 需要权威规范才能编码的模糊情况

---

## 验证命令

修改代码后执行：

```bash
pnpm check              # 类型检查 + ESLint（推荐）
pnpm test               # 单元测试
pnpm run build          # 构建验证
```
